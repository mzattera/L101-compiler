/*
 * generated by Xtext 2.18.0
 */
package org.mzattera.dsl.validation

import java.util.HashSet
import java.util.Set
import org.eclipse.xtext.validation.Check
import org.mzattera.dsl.l101.BreakStatement
import org.mzattera.dsl.l101.Constant
import org.mzattera.dsl.l101.ContinueStatement
import org.mzattera.dsl.l101.GotoStatement
import org.mzattera.dsl.l101.IfStatement
import org.mzattera.dsl.l101.L101Package
import org.mzattera.dsl.l101.Label
import org.mzattera.dsl.l101.Program
import org.mzattera.dsl.l101.Statement
import org.mzattera.dsl.l101.Variable
import org.mzattera.dsl.l101.VariableDeclaration

import static extension org.mzattera.dsl.util.Extensions.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class L101Validator extends AbstractL101Validator {

	static val ISSUE_CODE_PREFIX = "org.mzattera.dsl.validation"
	
	public static val DUPLICATED_KEY = ISSUE_CODE_PREFIX + "DuplicatedKey"
	public static val DUPLICATED_REGISTER = ISSUE_CODE_PREFIX + "DuplicatedRegister"
	public static val INCONSISTENT_REGISTER = ISSUE_CODE_PREFIX + "InconsistentRegister"
	public static val CONTINUE_CONTAINER = ISSUE_CODE_PREFIX + "ContinueContainer"
	public static val BREAK_CONTAINER = ISSUE_CODE_PREFIX + "BreakContainer"
	public static val EMPTY_IF = ISSUE_CODE_PREFIX + "EmptyIf"
	public static val LONG_CONSTANT = ISSUE_CODE_PREFIX + "LongConstants"
	public static val UNREACHABLE_CODE = ISSUE_CODE_PREFIX + "UnreachableCode"
	public static val UNUSED_LABEL = ISSUE_CODE_PREFIX + "UnusedLabel"

	/**
	 *  In a program registers must be used consistently
	 */
	@Check
	def checkRegisters(Program prg) {
		var Set<String> used = new HashSet<String>()
		var Set<String> lng = new HashSet<String>()
		var Set<String> shr = new HashSet<String>()

		for (VariableDeclaration dec : prg.varDeclarations) {
			for (Variable v : dec.vars) {

				if (used.contains(v.reg)) {
					error("Duplicated register.", v, L101Package.eINSTANCE.getVariable_Reg, DUPLICATED_REGISTER)
				} else if (dec.isShort) {
					// Short variable
					var fr = Character.toString(v.reg.charAt(0))
					if (lng.contains(fr)) {
						error("Register used inconsistently (both for LONG and SHORT).", v,
							L101Package.eINSTANCE.getVariable_Reg, INCONSISTENT_REGISTER)
					}
					shr.add(v.reg)
				} else {
					// Long variable
					if (v.reg.length() > 1) {
						error("Short register cannot be used for LONG variable.", v,
							L101Package.eINSTANCE.getVariable_Reg, INCONSISTENT_REGISTER)
					}
					if (shr.contains(v.reg) || shr.contains(v.reg + "/")) {
						error("Register used inconsistently (both for LONG and SHORT).", v,
							L101Package.eINSTANCE.getVariable_Reg, INCONSISTENT_REGISTER)
					}

					lng.add(v.reg)
				}

				used.add(v.reg)
			} // for each variable
		} // for each variable declaration
	}

	/**
	 * Constants at maximum have 11 digits. WHY? P101Emul breaks if longer.
	 */
	@Check
	def checkConstLength(Constant c) {
		if (c.value.replaceAll('\\.', '').length > 11)
			error("Numeric constant too long.", c, L101Package.eINSTANCE.getConstant_Value, LONG_CONSTANT)
	}

	/**
	 * In a program only 4 distinct labels can be assigned to VWYZ keys
	 */
	@Check
	def checkLabelAssignments(Program prg) {

		var Set<String> used = new HashSet<String>()

		val labels = prg.eAllContents.filter[it instanceof Label];
		while (labels.hasNext()) {
			val lbl = labels.next() as Label;
			if (lbl.target !== null) {
				if (used.contains(lbl.target))
					error("Duplicated key assignment for label.", lbl, L101Package.eINSTANCE.getLabel_Target,
						DUPLICATED_KEY)
				else
					used.add(lbl.target)
			}
		}
	}

	/**
	 * Check wheter all declared labels are used.
	 */
	@Check
	def checkUnusedLabels(Program prg) {

		// All labels that are referenced
		var Set<Label> used = new HashSet<Label>()
		val gotos = prg.eAllContents.filter[it instanceof GotoStatement];
		while (gotos.hasNext())
			used.add((gotos.next() as GotoStatement).label)

		val labels = prg.eAllContents.filter[it instanceof Label];
		while (labels.hasNext()) {
			val lbl = labels.next() as Label;
			if ((lbl.target === null) && !used.contains(lbl)) {
				warning("Unused label: " + lbl.name, lbl, L101Package.eINSTANCE.getLabel_Name, UNUSED_LABEL)
			}
		}
	}

	/**
	 * Unreachable code check.
	 * If a statement is in Statements and the preceding statement is GOTO BREAK CONTINUE, code is unreachable.
	 * Issue an error (or warning?). It will work also for an optimized GOTO.
	 */
	@Check
	def checkUnreachableCode(Statement stmt) {

		// labels can be anywhere
		if(stmt instanceof Label) return;
		// the error is on a generic statement in program, therefore this must be made generic by using eCore "introspection".
		val container = stmt.eContainer;
		var index = container.eContents.indexOf(stmt);
		if (index > 0) {
			val prec = container.eContents.get(index - 1)
			if ((prec instanceof GotoStatement) || (prec instanceof BreakStatement) ||
				(prec instanceof ContinueStatement))
				warning("Unreachable code.", container, stmt.eContainingFeature(), index,
					L101Validator.UNREACHABLE_CODE);
		}
	}

	/**
	 * Continue statements must be contained in a loop.
	 */
	@Check
	def checkContinueContainer(ContinueStatement stmt) {
		if (stmt.getContainingLoop === null) {
			error("CONTINUE statement must be contained within a loop.", stmt,
				L101Package.eINSTANCE.getSimpleControlStatement_Code, L101Validator.CONTINUE_CONTAINER)
		}
	}

	/**
	 * Break statements must be contained in a loop.
	 */
	@Check
	def checkBreakContainer(BreakStatement stmt) {
		if (stmt.getContainingLoop === null) {
			error("BREAK statement must be contained within a loop.", stmt,
				L101Package.eINSTANCE.getSimpleControlStatement_Code, L101Validator.BREAK_CONTAINER)
		}
	}

	/**
	 * IF statements must either have a non-empty THEN or an ELSE clause.
	 */
	@Check
	def checkIf(IfStatement stmt) {
		if (stmt.isThenEmpty && stmt.isElseEmpty) {
			error("IF statement must either have a non-empty THEN or ELSE clause.", stmt,
				L101Package.eINSTANCE.getIfStatement_Code, L101Validator.EMPTY_IF)
		}
	}
}
