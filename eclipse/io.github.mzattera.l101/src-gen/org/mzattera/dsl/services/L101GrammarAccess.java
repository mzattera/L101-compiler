/*
 * generated by Xtext 2.40.0
 */
package org.mzattera.dsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class L101GrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarDeclarationsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarDeclarationsVariableDeclarationParserRuleCall_0_0 = (RuleCall)cVarDeclarationsAssignment_0.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyStatementsParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//Program:
		//    (varDeclarations+=VariableDeclaration)*
		//    body=Statements
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(varDeclarations+=VariableDeclaration)*
		//body=Statements
		public Group getGroup() { return cGroup; }
		
		//(varDeclarations+=VariableDeclaration)*
		public Assignment getVarDeclarationsAssignment_0() { return cVarDeclarationsAssignment_0; }
		
		//VariableDeclaration
		public RuleCall getVarDeclarationsVariableDeclarationParserRuleCall_0_0() { return cVarDeclarationsVariableDeclarationParserRuleCall_0_0; }
		
		//body=Statements
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }
		
		//Statements
		public RuleCall getBodyStatementsParserRuleCall_1_0() { return cBodyStatementsParserRuleCall_1_0; }
	}
	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cShortAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cShortSHORTKeyword_0_0_0 = (Keyword)cShortAssignment_0_0.eContents().get(0);
		private final Keyword cLONGKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Assignment cVarsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarsVariableParserRuleCall_1_0 = (RuleCall)cVarsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVarsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVarsVariableParserRuleCall_2_1_0 = (RuleCall)cVarsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//VariableDeclaration:
		//    (short?='SHORT' | 'LONG') vars+=Variable (',' vars+=Variable)* ';'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(short?='SHORT' | 'LONG') vars+=Variable (',' vars+=Variable)* ';'
		public Group getGroup() { return cGroup; }
		
		//(short?='SHORT' | 'LONG')
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//short?='SHORT'
		public Assignment getShortAssignment_0_0() { return cShortAssignment_0_0; }
		
		//'SHORT'
		public Keyword getShortSHORTKeyword_0_0_0() { return cShortSHORTKeyword_0_0_0; }
		
		//'LONG'
		public Keyword getLONGKeyword_0_1() { return cLONGKeyword_0_1; }
		
		//vars+=Variable
		public Assignment getVarsAssignment_1() { return cVarsAssignment_1; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_1_0() { return cVarsVariableParserRuleCall_1_0; }
		
		//(',' vars+=Variable)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//vars+=Variable
		public Assignment getVarsAssignment_2_1() { return cVarsAssignment_2_1; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_2_1_0() { return cVarsVariableParserRuleCall_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cINKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRegAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cRegAlternatives_2_0 = (Alternatives)cRegAssignment_2.eContents().get(0);
		private final Keyword cRegBKeyword_2_0_0 = (Keyword)cRegAlternatives_2_0.eContents().get(0);
		private final Keyword cRegBKeyword_2_0_1 = (Keyword)cRegAlternatives_2_0.eContents().get(1);
		private final Keyword cRegCKeyword_2_0_2 = (Keyword)cRegAlternatives_2_0.eContents().get(2);
		private final Keyword cRegCKeyword_2_0_3 = (Keyword)cRegAlternatives_2_0.eContents().get(3);
		private final Keyword cRegDKeyword_2_0_4 = (Keyword)cRegAlternatives_2_0.eContents().get(4);
		private final Keyword cRegDKeyword_2_0_5 = (Keyword)cRegAlternatives_2_0.eContents().get(5);
		private final Keyword cRegEKeyword_2_0_6 = (Keyword)cRegAlternatives_2_0.eContents().get(6);
		private final Keyword cRegEKeyword_2_0_7 = (Keyword)cRegAlternatives_2_0.eContents().get(7);
		private final Keyword cRegFKeyword_2_0_8 = (Keyword)cRegAlternatives_2_0.eContents().get(8);
		private final Keyword cRegFKeyword_2_0_9 = (Keyword)cRegAlternatives_2_0.eContents().get(9);
		
		//// Even though it would be possible to automatically allocate variables, we don't because then variables
		//// can be recognized when a register is printed.
		//// Constant assignment cannot be done because the program entry point is unknown.
		//Variable:
		//    name=ID 'IN' reg=('B' | 'B/' | 'C' | 'C/' | 'D' | 'D/' | 'E' | 'E/' | 'F' | 'F/')
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID 'IN' reg=('B' | 'B/' | 'C' | 'C/' | 'D' | 'D/' | 'E' | 'E/' | 'F' | 'F/')
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'IN'
		public Keyword getINKeyword_1() { return cINKeyword_1; }
		
		//reg=('B' | 'B/' | 'C' | 'C/' | 'D' | 'D/' | 'E' | 'E/' | 'F' | 'F/')
		public Assignment getRegAssignment_2() { return cRegAssignment_2; }
		
		//('B' | 'B/' | 'C' | 'C/' | 'D' | 'D/' | 'E' | 'E/' | 'F' | 'F/')
		public Alternatives getRegAlternatives_2_0() { return cRegAlternatives_2_0; }
		
		//'B'
		public Keyword getRegBKeyword_2_0_0() { return cRegBKeyword_2_0_0; }
		
		//'B/'
		public Keyword getRegBKeyword_2_0_1() { return cRegBKeyword_2_0_1; }
		
		//'C'
		public Keyword getRegCKeyword_2_0_2() { return cRegCKeyword_2_0_2; }
		
		//'C/'
		public Keyword getRegCKeyword_2_0_3() { return cRegCKeyword_2_0_3; }
		
		//'D'
		public Keyword getRegDKeyword_2_0_4() { return cRegDKeyword_2_0_4; }
		
		//'D/'
		public Keyword getRegDKeyword_2_0_5() { return cRegDKeyword_2_0_5; }
		
		//'E'
		public Keyword getRegEKeyword_2_0_6() { return cRegEKeyword_2_0_6; }
		
		//'E/'
		public Keyword getRegEKeyword_2_0_7() { return cRegEKeyword_2_0_7; }
		
		//'F'
		public Keyword getRegFKeyword_2_0_8() { return cRegFKeyword_2_0_8; }
		
		//'F/'
		public Keyword getRegFKeyword_2_0_9() { return cRegFKeyword_2_0_9; }
	}
	public class VariableAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.VariableAccess");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableAccessAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cStoreAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cStoreVariableCrossReference_1_0 = (CrossReference)cStoreAssignment_1.eContents().get(0);
		private final RuleCall cStoreVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cStoreVariableCrossReference_1_0.eContents().get(1);
		
		//// Pay attention this is scoped, therefore if you change feature names you need to change the scope provider.
		//VariableAccess returns Expression:
		//    {VariableAccess} store=[Variable]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{VariableAccess} store=[Variable]
		public Group getGroup() { return cGroup; }
		
		//{VariableAccess}
		public Action getVariableAccessAction_0() { return cVariableAccessAction_0; }
		
		//store=[Variable]
		public Assignment getStoreAssignment_1() { return cStoreAssignment_1; }
		
		//[Variable]
		public CrossReference getStoreVariableCrossReference_1_0() { return cStoreVariableCrossReference_1_0; }
		
		//ID
		public RuleCall getStoreVariableIDTerminalRuleCall_1_0_1() { return cStoreVariableIDTerminalRuleCall_1_0_1; }
	}
	public class VariableOrUserInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.VariableOrUserInput");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableAccessParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUserInputParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//VariableOrUserInput returns Expression:
		//    VariableAccess
		//    | UserInput
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//VariableAccess
		//| UserInput
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VariableAccess
		public RuleCall getVariableAccessParserRuleCall_0() { return cVariableAccessParserRuleCall_0; }
		
		//UserInput
		public RuleCall getUserInputParserRuleCall_1() { return cUserInputParserRuleCall_1; }
	}
	public class AssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.AssignmentStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cOpAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_0_0_0 = (Keyword)cOpAssignment_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_0_1_0 = (RuleCall)cOperandAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cOpAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Alternatives cOpAlternatives_1_0_0 = (Alternatives)cOpAssignment_1_0.eContents().get(0);
		private final Keyword cOpPlusSignEqualsSignKeyword_1_0_0_0 = (Keyword)cOpAlternatives_1_0_0.eContents().get(0);
		private final Keyword cOpHyphenMinusEqualsSignKeyword_1_0_0_1 = (Keyword)cOpAlternatives_1_0_0.eContents().get(1);
		private final Keyword cOpSolidusEqualsSignKeyword_1_0_0_2 = (Keyword)cOpAlternatives_1_0_0.eContents().get(2);
		private final Keyword cOpAsteriskEqualsSignKeyword_1_0_0_3 = (Keyword)cOpAlternatives_1_0_0.eContents().get(3);
		private final Keyword cOpPercentSignEqualsSignKeyword_1_0_0_4 = (Keyword)cOpAlternatives_1_0_0.eContents().get(4);
		private final Assignment cOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperandAlternatives_1_1_0 = (Alternatives)cOperandAssignment_1_1.eContents().get(0);
		private final RuleCall cOperandVariableOrUserInputParserRuleCall_1_1_0_0 = (RuleCall)cOperandAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cOperandCurrentParserRuleCall_1_1_0_1 = (RuleCall)cOperandAlternatives_1_1_0.eContents().get(1);
		private final RuleCall cOperandConstantParserRuleCall_1_1_0_2 = (RuleCall)cOperandAlternatives_1_1_0.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cStoreAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cStoreVariableAccessParserRuleCall_2_0_0 = (RuleCall)cStoreAssignment_2_0.eContents().get(0);
		private final Assignment cOpAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Keyword cOpLessThanSignHyphenMinusGreaterThanSignKeyword_2_1_0 = (Keyword)cOpAssignment_2_1.eContents().get(0);
		private final Assignment cOperandAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cOperandExpressionParserRuleCall_2_2_0 = (RuleCall)cOperandAssignment_2_2.eContents().get(0);
		
		//    /// Expressions ////////////////////////////////////////////////////////////////////
		//    /*
		//     * We have 2 options here I think.
		//     *
		//     * 1) Allow 'A' to appear both as left and right operand with the meaning of "current value in A" and remove the "auto-assignment" operators.
		//     * This will allow more compact syntax but could be error prone because it has side effects:
		//     * A=1   A+A+A =4 (and not 3: (A+A) puts a two in A then +A sums 2+2)
		//     *
		//     * 2) Current situation: allow A to appear only a) as left operand and b) on the right of "auto-assignment" operators.
		//     * a) removes side effects because, given current syntax, A will appear only once in expressions as the first term to be evaluated
		//     * b) clearly shows when A is changed and again A value is read only once.
		//     * Syntax is less error prone but more complex and less concise though.
		//     */
		//AssignmentStatement:
		//    // x % y performs x/y then the "exact reminder" (content of R) is moved to A
		//    // Compute expression and stores it in A
		//    op='=' operand=Expression
		//    // Computes A = A <op> A/INPUT/Variable/Constant
		//    // this allows you to calculate A=A+A as +=A; which is not allowed with "=" statement alone for the above reasons.
		//    | op=('+=' | '-=' | '/=' | '*=' | '%=') operand=(VariableOrUserInput | Current | Constant)
		//    // Computes expression in A then swaps A with given variable
		//    | store=VariableAccess op='<->' operand=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// x % y performs x/y then the "exact reminder" (content of R) is moved to A
		//// Compute expression and stores it in A
		//op='=' operand=Expression
		//// Computes A = A <op> A/INPUT/Variable/Constant
		//// this allows you to calculate A=A+A as +=A; which is not allowed with "=" statement alone for the above reasons.
		//| op=('+=' | '-=' | '/=' | '*=' | '%=') operand=(VariableOrUserInput | Current | Constant)
		//// Computes expression in A then swaps A with given variable
		//| store=VariableAccess op='<->' operand=Expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//// x % y performs x/y then the "exact reminder" (content of R) is moved to A
		//// Compute expression and stores it in A
		//op='=' operand=Expression
		public Group getGroup_0() { return cGroup_0; }
		
		//// x % y performs x/y then the "exact reminder" (content of R) is moved to A
		//// Compute expression and stores it in A
		//op='='
		public Assignment getOpAssignment_0_0() { return cOpAssignment_0_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_0_0_0() { return cOpEqualsSignKeyword_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_0_1() { return cOperandAssignment_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_0_1_0() { return cOperandExpressionParserRuleCall_0_1_0; }
		
		//op=('+=' | '-=' | '/=' | '*=' | '%=') operand=(VariableOrUserInput | Current | Constant)
		public Group getGroup_1() { return cGroup_1; }
		
		//op=('+=' | '-=' | '/=' | '*=' | '%=')
		public Assignment getOpAssignment_1_0() { return cOpAssignment_1_0; }
		
		//('+=' | '-=' | '/=' | '*=' | '%=')
		public Alternatives getOpAlternatives_1_0_0() { return cOpAlternatives_1_0_0; }
		
		//'+='
		public Keyword getOpPlusSignEqualsSignKeyword_1_0_0_0() { return cOpPlusSignEqualsSignKeyword_1_0_0_0; }
		
		//'-='
		public Keyword getOpHyphenMinusEqualsSignKeyword_1_0_0_1() { return cOpHyphenMinusEqualsSignKeyword_1_0_0_1; }
		
		//'/='
		public Keyword getOpSolidusEqualsSignKeyword_1_0_0_2() { return cOpSolidusEqualsSignKeyword_1_0_0_2; }
		
		//'*='
		public Keyword getOpAsteriskEqualsSignKeyword_1_0_0_3() { return cOpAsteriskEqualsSignKeyword_1_0_0_3; }
		
		//'%='
		public Keyword getOpPercentSignEqualsSignKeyword_1_0_0_4() { return cOpPercentSignEqualsSignKeyword_1_0_0_4; }
		
		//operand=(VariableOrUserInput | Current | Constant)
		public Assignment getOperandAssignment_1_1() { return cOperandAssignment_1_1; }
		
		//(VariableOrUserInput | Current | Constant)
		public Alternatives getOperandAlternatives_1_1_0() { return cOperandAlternatives_1_1_0; }
		
		//VariableOrUserInput
		public RuleCall getOperandVariableOrUserInputParserRuleCall_1_1_0_0() { return cOperandVariableOrUserInputParserRuleCall_1_1_0_0; }
		
		//Current
		public RuleCall getOperandCurrentParserRuleCall_1_1_0_1() { return cOperandCurrentParserRuleCall_1_1_0_1; }
		
		//Constant
		public RuleCall getOperandConstantParserRuleCall_1_1_0_2() { return cOperandConstantParserRuleCall_1_1_0_2; }
		
		//store=VariableAccess op='<->' operand=Expression
		public Group getGroup_2() { return cGroup_2; }
		
		//store=VariableAccess
		public Assignment getStoreAssignment_2_0() { return cStoreAssignment_2_0; }
		
		//VariableAccess
		public RuleCall getStoreVariableAccessParserRuleCall_2_0_0() { return cStoreVariableAccessParserRuleCall_2_0_0; }
		
		//op='<->'
		public Assignment getOpAssignment_2_1() { return cOpAssignment_2_1; }
		
		//'<->'
		public Keyword getOpLessThanSignHyphenMinusGreaterThanSignKeyword_2_1_0() { return cOpLessThanSignHyphenMinusGreaterThanSignKeyword_2_1_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_2_2() { return cOperandAssignment_2_2; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_2_2_0() { return cOperandExpressionParserRuleCall_2_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Expression");
		private final RuleCall cAdditiveOperatorParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// TODO 3 - write test code to check expressions (precedence, associativity)
		//Expression:
		//    AdditiveOperator
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//AdditiveOperator
		public RuleCall getAdditiveOperatorParserRuleCall() { return cAdditiveOperatorParserRuleCall; }
	}
	public class AdditiveOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.AdditiveOperator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeOperatorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditiveOperatorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cRightAlternatives_1_2_0 = (Alternatives)cRightAssignment_1_2.eContents().get(0);
		private final RuleCall cRightVariableOrUserInputParserRuleCall_1_2_0_0 = (RuleCall)cRightAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cRightConstantParserRuleCall_1_2_0_1 = (RuleCall)cRightAlternatives_1_2_0.eContents().get(1);
		
		//AdditiveOperator returns Expression: // left associative
		//    MultiplicativeOperator ({AdditiveOperator.left=current} op=('+' | '-') right=(VariableOrUserInput | Constant))*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// left associative
		//   MultiplicativeOperator ({AdditiveOperator.left=current} op=('+' | '-') right=(VariableOrUserInput | Constant))*
		public Group getGroup() { return cGroup; }
		
		//// left associative
		//   MultiplicativeOperator
		public RuleCall getMultiplicativeOperatorParserRuleCall_0() { return cMultiplicativeOperatorParserRuleCall_0; }
		
		//({AdditiveOperator.left=current} op=('+' | '-') right=(VariableOrUserInput | Constant))*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AdditiveOperator.left=current}
		public Action getAdditiveOperatorLeftAction_1_0() { return cAdditiveOperatorLeftAction_1_0; }
		
		//op=('+' | '-')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('+' | '-')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_1_1_0_0() { return cOpPlusSignKeyword_1_1_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_1_1_0_1() { return cOpHyphenMinusKeyword_1_1_0_1; }
		
		//right=(VariableOrUserInput | Constant)
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//(VariableOrUserInput | Constant)
		public Alternatives getRightAlternatives_1_2_0() { return cRightAlternatives_1_2_0; }
		
		//VariableOrUserInput
		public RuleCall getRightVariableOrUserInputParserRuleCall_1_2_0_0() { return cRightVariableOrUserInputParserRuleCall_1_2_0_0; }
		
		//Constant
		public RuleCall getRightConstantParserRuleCall_1_2_0_1() { return cRightConstantParserRuleCall_1_2_0_1; }
	}
	public class MultiplicativeOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.MultiplicativeOperator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOperatorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicativeOperatorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpPercentSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cRightAlternatives_1_2_0 = (Alternatives)cRightAssignment_1_2.eContents().get(0);
		private final RuleCall cRightVariableOrUserInputParserRuleCall_1_2_0_0 = (RuleCall)cRightAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cRightConstantParserRuleCall_1_2_0_1 = (RuleCall)cRightAlternatives_1_2_0.eContents().get(1);
		
		//MultiplicativeOperator returns Expression: // left associative
		//    // x % y performs x/y then the "exact reminder" (content of R) is moved to A
		//    UnaryOperator ({MultiplicativeOperator.left=current} op=('*' | '/' | '%') right=(VariableOrUserInput | Constant))*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// left associative
		//   // x % y performs x/y then the "exact reminder" (content of R) is moved to A
		//   UnaryOperator ({MultiplicativeOperator.left=current} op=('*' | '/' | '%') right=(VariableOrUserInput | Constant))*
		public Group getGroup() { return cGroup; }
		
		//// left associative
		//   // x % y performs x/y then the "exact reminder" (content of R) is moved to A
		//   UnaryOperator
		public RuleCall getUnaryOperatorParserRuleCall_0() { return cUnaryOperatorParserRuleCall_0; }
		
		//({MultiplicativeOperator.left=current} op=('*' | '/' | '%') right=(VariableOrUserInput | Constant))*
		public Group getGroup_1() { return cGroup_1; }
		
		//{MultiplicativeOperator.left=current}
		public Action getMultiplicativeOperatorLeftAction_1_0() { return cMultiplicativeOperatorLeftAction_1_0; }
		
		//op=('*' | '/' | '%')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('*' | '/' | '%')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_1_1_0_0() { return cOpAsteriskKeyword_1_1_0_0; }
		
		//'/'
		public Keyword getOpSolidusKeyword_1_1_0_1() { return cOpSolidusKeyword_1_1_0_1; }
		
		//'%'
		public Keyword getOpPercentSignKeyword_1_1_0_2() { return cOpPercentSignKeyword_1_1_0_2; }
		
		//right=(VariableOrUserInput | Constant)
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//(VariableOrUserInput | Constant)
		public Alternatives getRightAlternatives_1_2_0() { return cRightAlternatives_1_2_0; }
		
		//VariableOrUserInput
		public RuleCall getRightVariableOrUserInputParserRuleCall_1_2_0_0() { return cRightVariableOrUserInputParserRuleCall_1_2_0_0; }
		
		//Constant
		public RuleCall getRightConstantParserRuleCall_1_2_0_1() { return cRightConstantParserRuleCall_1_2_0_1; }
	}
	public class UnaryOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryOperatorAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cOpAlternatives_0_1_0 = (Alternatives)cOpAssignment_0_1.eContents().get(0);
		private final Keyword cOpSQKeyword_0_1_0_0 = (Keyword)cOpAlternatives_0_1_0.eContents().get(0);
		private final Keyword cOpSQRTKeyword_0_1_0_1 = (Keyword)cOpAlternatives_0_1_0.eContents().get(1);
		private final Keyword cOpINTKeyword_0_1_0_2 = (Keyword)cOpAlternatives_0_1_0.eContents().get(2);
		private final Keyword cOpDECKeyword_0_1_0_3 = (Keyword)cOpAlternatives_0_1_0.eContents().get(3);
		private final Keyword cOpINVKeyword_0_1_0_4 = (Keyword)cOpAlternatives_0_1_0.eContents().get(4);
		private final Keyword cOpNEGKeyword_0_1_0_5 = (Keyword)cOpAlternatives_0_1_0.eContents().get(5);
		private final Keyword cOpABSKeyword_0_1_0_6 = (Keyword)cOpAlternatives_0_1_0.eContents().get(6);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandUnaryOperatorParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final RuleCall cAtomicParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UnaryOperator returns Expression: // right associative
		//    {UnaryOperator} op=('SQ' | 'SQRT' | 'INT' | 'DEC' | 'INV' | 'NEG' | 'ABS') operand=(UnaryOperator)
		//    | Atomic
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// right associative
		//   {UnaryOperator} op=('SQ' | 'SQRT' | 'INT' | 'DEC' | 'INV' | 'NEG' | 'ABS') operand=(UnaryOperator)
		//   | Atomic
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//// right associative
		//   {UnaryOperator} op=('SQ' | 'SQRT' | 'INT' | 'DEC' | 'INV' | 'NEG' | 'ABS') operand=(UnaryOperator)
		public Group getGroup_0() { return cGroup_0; }
		
		//// right associative
		//   {UnaryOperator}
		public Action getUnaryOperatorAction_0_0() { return cUnaryOperatorAction_0_0; }
		
		//op=('SQ' | 'SQRT' | 'INT' | 'DEC' | 'INV' | 'NEG' | 'ABS')
		public Assignment getOpAssignment_0_1() { return cOpAssignment_0_1; }
		
		//('SQ' | 'SQRT' | 'INT' | 'DEC' | 'INV' | 'NEG' | 'ABS')
		public Alternatives getOpAlternatives_0_1_0() { return cOpAlternatives_0_1_0; }
		
		//'SQ'
		public Keyword getOpSQKeyword_0_1_0_0() { return cOpSQKeyword_0_1_0_0; }
		
		//'SQRT'
		public Keyword getOpSQRTKeyword_0_1_0_1() { return cOpSQRTKeyword_0_1_0_1; }
		
		//'INT'
		public Keyword getOpINTKeyword_0_1_0_2() { return cOpINTKeyword_0_1_0_2; }
		
		//'DEC'
		public Keyword getOpDECKeyword_0_1_0_3() { return cOpDECKeyword_0_1_0_3; }
		
		//'INV'
		public Keyword getOpINVKeyword_0_1_0_4() { return cOpINVKeyword_0_1_0_4; }
		
		//'NEG'
		public Keyword getOpNEGKeyword_0_1_0_5() { return cOpNEGKeyword_0_1_0_5; }
		
		//'ABS'
		public Keyword getOpABSKeyword_0_1_0_6() { return cOpABSKeyword_0_1_0_6; }
		
		//operand=(UnaryOperator)
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//(UnaryOperator)
		public RuleCall getOperandUnaryOperatorParserRuleCall_0_2_0() { return cOperandUnaryOperatorParserRuleCall_0_2_0; }
		
		//Atomic
		public RuleCall getAtomicParserRuleCall_1() { return cAtomicParserRuleCall_1; }
	}
	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Atomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableAccessParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCurrentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUserInputParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//Atomic returns Expression:
		//    VariableAccess
		//    | Current
		//    | UserInput
		//    | Constant
		//    | '(' Expression ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//VariableAccess
		//| Current
		//| UserInput
		//| Constant
		//| '(' Expression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VariableAccess
		public RuleCall getVariableAccessParserRuleCall_0() { return cVariableAccessParserRuleCall_0; }
		
		//Current
		public RuleCall getCurrentParserRuleCall_1() { return cCurrentParserRuleCall_1; }
		
		//UserInput
		public RuleCall getUserInputParserRuleCall_2() { return cUserInputParserRuleCall_2; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_3() { return cConstantParserRuleCall_3; }
		
		//'(' Expression ')'
		public Group getGroup_4() { return cGroup_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_4_1() { return cExpressionParserRuleCall_4_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class CurrentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Current");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCurrentAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Current returns Expression:
		//    {Current} 'A'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Current} 'A'
		public Group getGroup() { return cGroup; }
		
		//{Current}
		public Action getCurrentAction_0() { return cCurrentAction_0; }
		
		//'A'
		public Keyword getAKeyword_1() { return cAKeyword_1; }
	}
	public class UserInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.UserInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInputAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cINPUTKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//UserInput returns Expression:
		//    {Input} 'INPUT'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Input} 'INPUT'
		public Group getGroup() { return cGroup; }
		
		//{Input}
		public Action getInputAction_0() { return cInputAction_0; }
		
		//'INPUT'
		public Keyword getINPUTKeyword_1() { return cINPUTKeyword_1; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNegativeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNegativeHyphenMinusKeyword_1_0 = (Keyword)cNegativeAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueNUMBERTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Constant returns Expression:
		//// Not ideal, as can be space between - and the number,but necessary otherwise i-10 won't be parsed (-10 will be a single indivisible token)
		//// Notice it is the same in Java.
		//// Notice maximum number of digit in a constant is 11.
		//    {Constant} negative?='-'? value=NUMBER
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// Not ideal, as can be space between - and the number,but necessary otherwise i-10 won't be parsed (-10 will be a single indivisible token)
		//// Notice it is the same in Java.
		//// Notice maximum number of digit in a constant is 11.
		//    {Constant} negative?='-'? value=NUMBER
		public Group getGroup() { return cGroup; }
		
		//// Not ideal, as can be space between - and the number,but necessary otherwise i-10 won't be parsed (-10 will be a single indivisible token)
		//// Notice it is the same in Java.
		//// Notice maximum number of digit in a constant is 11.
		//    {Constant}
		public Action getConstantAction_0() { return cConstantAction_0; }
		
		//negative?='-'?
		public Assignment getNegativeAssignment_1() { return cNegativeAssignment_1; }
		
		//'-'
		public Keyword getNegativeHyphenMinusKeyword_1_0() { return cNegativeHyphenMinusKeyword_1_0; }
		
		//value=NUMBER
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//NUMBER
		public RuleCall getValueNUMBERTerminalRuleCall_2_0() { return cValueNUMBERTerminalRuleCall_2_0; }
	}
	public class StatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Statements");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatementsAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		
		///// Statements ///////////////////////////////////////////////////
		//Statements:
		//        {Statements} (statements+=Statement)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Statements} (statements+=Statement)*
		public Group getGroup() { return cGroup; }
		
		//{Statements}
		public Action getStatementsAction_0() { return cStatementsAction_0; }
		
		//(statements+=Statement)*
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_1_0() { return cStatementsStatementParserRuleCall_1_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLabelParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cAssignmentStatementParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cSimpleStatementParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cSimpleControlStatementParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final RuleCall cStructuredControlStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Statement:
		//    Label
		//    | AssignmentStatement ';'
		//    | SimpleStatement ';'
		//    | SimpleControlStatement ';'
		//    | StructuredControlStatement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Label
		//| AssignmentStatement ';'
		//| SimpleStatement ';'
		//| SimpleControlStatement ';'
		//| StructuredControlStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Label
		public RuleCall getLabelParserRuleCall_0() { return cLabelParserRuleCall_0; }
		
		//AssignmentStatement ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//AssignmentStatement
		public RuleCall getAssignmentStatementParserRuleCall_1_0() { return cAssignmentStatementParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
		
		//SimpleStatement ';'
		public Group getGroup_2() { return cGroup_2; }
		
		//SimpleStatement
		public RuleCall getSimpleStatementParserRuleCall_2_0() { return cSimpleStatementParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
		
		//SimpleControlStatement ';'
		public Group getGroup_3() { return cGroup_3; }
		
		//SimpleControlStatement
		public RuleCall getSimpleControlStatementParserRuleCall_3_0() { return cSimpleControlStatementParserRuleCall_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3_1() { return cSemicolonKeyword_3_1; }
		
		//StructuredControlStatement
		public RuleCall getStructuredControlStatementParserRuleCall_4() { return cStructuredControlStatementParserRuleCall_4; }
	}
	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.Label");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cONKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTargetAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cTargetAlternatives_1_1_0 = (Alternatives)cTargetAssignment_1_1.eContents().get(0);
		private final Keyword cTargetVKeyword_1_1_0_0 = (Keyword)cTargetAlternatives_1_1_0.eContents().get(0);
		private final Keyword cTargetWKeyword_1_1_0_1 = (Keyword)cTargetAlternatives_1_1_0.eContents().get(1);
		private final Keyword cTargetYKeyword_1_1_0_2 = (Keyword)cTargetAlternatives_1_1_0.eContents().get(2);
		private final Keyword cTargetZKeyword_1_1_0_3 = (Keyword)cTargetAlternatives_1_1_0.eContents().get(3);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Label:
		//    name=ID ('ON' target=('V' | 'W' | 'Y' | 'Z'))? ':'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ('ON' target=('V' | 'W' | 'Y' | 'Z'))? ':'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//('ON' target=('V' | 'W' | 'Y' | 'Z'))?
		public Group getGroup_1() { return cGroup_1; }
		
		//'ON'
		public Keyword getONKeyword_1_0() { return cONKeyword_1_0; }
		
		//target=('V' | 'W' | 'Y' | 'Z')
		public Assignment getTargetAssignment_1_1() { return cTargetAssignment_1_1; }
		
		//('V' | 'W' | 'Y' | 'Z')
		public Alternatives getTargetAlternatives_1_1_0() { return cTargetAlternatives_1_1_0; }
		
		//'V'
		public Keyword getTargetVKeyword_1_1_0_0() { return cTargetVKeyword_1_1_0_0; }
		
		//'W'
		public Keyword getTargetWKeyword_1_1_0_1() { return cTargetWKeyword_1_1_0_1; }
		
		//'Y'
		public Keyword getTargetYKeyword_1_1_0_2() { return cTargetYKeyword_1_1_0_2; }
		
		//'Z'
		public Keyword getTargetZKeyword_1_1_0_3() { return cTargetZKeyword_1_1_0_3; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
	}
	public class SimpleStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.SimpleStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStoreStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrintStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGotoStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//SimpleStatement:
		//    StoreStatement
		//    | PrintStatement
		//    | GotoStatement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//StoreStatement
		//| PrintStatement
		//| GotoStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//StoreStatement
		public RuleCall getStoreStatementParserRuleCall_0() { return cStoreStatementParserRuleCall_0; }
		
		//PrintStatement
		public RuleCall getPrintStatementParserRuleCall_1() { return cPrintStatementParserRuleCall_1; }
		
		//GotoStatement
		public RuleCall getGotoStatementParserRuleCall_2() { return cGotoStatementParserRuleCall_2; }
	}
	public class SimpleControlStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.SimpleControlStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cContinueStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBreakStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Keep these separate from SimpleStatemetns since they have different usage in FOR for example
		//SimpleControlStatement:
		//    ContinueStatement
		//    | BreakStatement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ContinueStatement
		//| BreakStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ContinueStatement
		public RuleCall getContinueStatementParserRuleCall_0() { return cContinueStatementParserRuleCall_0; }
		
		//BreakStatement
		public RuleCall getBreakStatementParserRuleCall_1() { return cBreakStatementParserRuleCall_1; }
	}
	public class StructuredControlStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.StructuredControlStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLoopStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//StructuredControlStatement:
		//    IfStatement
		//    | LoopStatement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//IfStatement
		//| LoopStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_0() { return cIfStatementParserRuleCall_0; }
		
		//LoopStatement
		public RuleCall getLoopStatementParserRuleCall_1() { return cLoopStatementParserRuleCall_1; }
	}
	public class LoopStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.LoopStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUntilStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//LoopStatement:
		//    UntilStatement
		//    | ForStatement
		//    | WhileStatement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//UntilStatement
		//| ForStatement
		//| WhileStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UntilStatement
		public RuleCall getUntilStatementParserRuleCall_0() { return cUntilStatementParserRuleCall_0; }
		
		//ForStatement
		public RuleCall getForStatementParserRuleCall_1() { return cForStatementParserRuleCall_1; }
		
		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_2() { return cWhileStatementParserRuleCall_2; }
	}
	public class StoreStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.StoreStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cParamAlternatives_0_0 = (Alternatives)cParamAssignment_0.eContents().get(0);
		private final RuleCall cParamConstantParserRuleCall_0_0_0 = (RuleCall)cParamAlternatives_0_0.eContents().get(0);
		private final RuleCall cParamUserInputParserRuleCall_0_0_1 = (RuleCall)cParamAlternatives_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStoreAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStoreVariableAccessParserRuleCall_2_0 = (RuleCall)cStoreAssignment_2.eContents().get(0);
		
		//StoreStatement:
		//    param=(Constant | UserInput) '->' store=VariableAccess
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//param=(Constant | UserInput) '->' store=VariableAccess
		public Group getGroup() { return cGroup; }
		
		//param=(Constant | UserInput)
		public Assignment getParamAssignment_0() { return cParamAssignment_0; }
		
		//(Constant | UserInput)
		public Alternatives getParamAlternatives_0_0() { return cParamAlternatives_0_0; }
		
		//Constant
		public RuleCall getParamConstantParserRuleCall_0_0_0() { return cParamConstantParserRuleCall_0_0_0; }
		
		//UserInput
		public RuleCall getParamUserInputParserRuleCall_0_0_1() { return cParamUserInputParserRuleCall_0_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//store=VariableAccess
		public Assignment getStoreAssignment_2() { return cStoreAssignment_2; }
		
		//VariableAccess
		public RuleCall getStoreVariableAccessParserRuleCall_2_0() { return cStoreVariableAccessParserRuleCall_2_0; }
	}
	public class PrintStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.PrintStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPrintStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPRINTKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParamsPrintParameterParserRuleCall_2_0_0 = (RuleCall)cParamsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParamsPrintParameterParserRuleCall_2_1_1_0 = (RuleCall)cParamsAssignment_2_1_1.eContents().get(0);
		
		//// Prints given parameters.
		//// Parameters can be a variable: prints its value, "Current": prints content of A,
		//// "NL" to print an empty line, "Constant" prints a number.
		//// If no parameters are provided, prints a new line.
		//PrintStatement:
		//    {PrintStatement} 'PRINT' (params+=PrintParameter (',' params+=PrintParameter)*)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{PrintStatement} 'PRINT' (params+=PrintParameter (',' params+=PrintParameter)*)?
		public Group getGroup() { return cGroup; }
		
		//{PrintStatement}
		public Action getPrintStatementAction_0() { return cPrintStatementAction_0; }
		
		//'PRINT'
		public Keyword getPRINTKeyword_1() { return cPRINTKeyword_1; }
		
		//(params+=PrintParameter (',' params+=PrintParameter)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//params+=PrintParameter
		public Assignment getParamsAssignment_2_0() { return cParamsAssignment_2_0; }
		
		//PrintParameter
		public RuleCall getParamsPrintParameterParserRuleCall_2_0_0() { return cParamsPrintParameterParserRuleCall_2_0_0; }
		
		//(',' params+=PrintParameter)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//params+=PrintParameter
		public Assignment getParamsAssignment_2_1_1() { return cParamsAssignment_2_1_1; }
		
		//PrintParameter
		public RuleCall getParamsPrintParameterParserRuleCall_2_1_1_0() { return cParamsPrintParameterParserRuleCall_2_1_1_0; }
	}
	public class PrintParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.PrintParameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableAccessParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCurrentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNewLineParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PrintParameter:
		//    VariableAccess
		//    | Current
		//    | Constant
		//    | NewLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//VariableAccess
		//| Current
		//| Constant
		//| NewLine
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VariableAccess
		public RuleCall getVariableAccessParserRuleCall_0() { return cVariableAccessParserRuleCall_0; }
		
		//Current
		public RuleCall getCurrentParserRuleCall_1() { return cCurrentParserRuleCall_1; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_2() { return cConstantParserRuleCall_2; }
		
		//NewLine
		public RuleCall getNewLineParserRuleCall_3() { return cNewLineParserRuleCall_3; }
	}
	public class NewLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.NewLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNewLineAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNLKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NewLine:
		//    {NewLine} 'NL'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{NewLine} 'NL'
		public Group getGroup() { return cGroup; }
		
		//{NewLine}
		public Action getNewLineAction_0() { return cNewLineAction_0; }
		
		//'NL'
		public Keyword getNLKeyword_1() { return cNLKeyword_1; }
	}
	public class GotoStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.GotoStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGOTOKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cLabelLabelCrossReference_1_0 = (CrossReference)cLabelAssignment_1.eContents().get(0);
		private final RuleCall cLabelLabelIDTerminalRuleCall_1_0_1 = (RuleCall)cLabelLabelCrossReference_1_0.eContents().get(1);
		
		//GotoStatement:
		//    'GOTO' label=[Label]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'GOTO' label=[Label]
		public Group getGroup() { return cGroup; }
		
		//'GOTO'
		public Keyword getGOTOKeyword_0() { return cGOTOKeyword_0; }
		
		//label=[Label]
		public Assignment getLabelAssignment_1() { return cLabelAssignment_1; }
		
		//[Label]
		public CrossReference getLabelLabelCrossReference_1_0() { return cLabelLabelCrossReference_1_0; }
		
		//ID
		public RuleCall getLabelLabelIDTerminalRuleCall_1_0_1() { return cLabelLabelIDTerminalRuleCall_1_0_1; }
	}
	public class ContinueStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.ContinueStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cContinueStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCodeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cCodeCONTINUEKeyword_1_0 = (Keyword)cCodeAssignment_1.eContents().get(0);
		
		//// Code is not really used, it used to point to a feature during validation
		//ContinueStatement:
		//    {ContinueStatement} code='CONTINUE'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{ContinueStatement} code='CONTINUE'
		public Group getGroup() { return cGroup; }
		
		//{ContinueStatement}
		public Action getContinueStatementAction_0() { return cContinueStatementAction_0; }
		
		//code='CONTINUE'
		public Assignment getCodeAssignment_1() { return cCodeAssignment_1; }
		
		//'CONTINUE'
		public Keyword getCodeCONTINUEKeyword_1_0() { return cCodeCONTINUEKeyword_1_0; }
	}
	public class BreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.BreakStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBreakStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCodeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cCodeBREAKKeyword_1_0 = (Keyword)cCodeAssignment_1.eContents().get(0);
		
		//// Code is not really used, it used to point to a feature during validation
		//BreakStatement:
		//    {BreakStatement} code='BREAK'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{BreakStatement} code='BREAK'
		public Group getGroup() { return cGroup; }
		
		//{BreakStatement}
		public Action getBreakStatementAction_0() { return cBreakStatementAction_0; }
		
		//code='BREAK'
		public Assignment getCodeAssignment_1() { return cCodeAssignment_1; }
		
		//'BREAK'
		public Keyword getCodeBREAKKeyword_1_0() { return cCodeBREAKKeyword_1_0; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cCodeIFKeyword_0_0 = (Keyword)cCodeAssignment_0.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionAssignmentStatementParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cTHENKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cThenClauseAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cThenClauseStatementsParserRuleCall_2_1_0 = (RuleCall)cThenClauseAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cELSEKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cElseClauseAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cElseClauseStatementsParserRuleCall_3_1_0 = (RuleCall)cElseClauseAssignment_3_1.eContents().get(0);
		private final Keyword cENDKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// Code is not really used, it used to point to a feature during validation
		//IfStatement:
		//    code='IF' condition=AssignmentStatement ('THEN' thenClause=Statements)? ('ELSE' elseClause=Statements)? 'END'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//code='IF' condition=AssignmentStatement ('THEN' thenClause=Statements)? ('ELSE' elseClause=Statements)? 'END'
		public Group getGroup() { return cGroup; }
		
		//code='IF'
		public Assignment getCodeAssignment_0() { return cCodeAssignment_0; }
		
		//'IF'
		public Keyword getCodeIFKeyword_0_0() { return cCodeIFKeyword_0_0; }
		
		//condition=AssignmentStatement
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//AssignmentStatement
		public RuleCall getConditionAssignmentStatementParserRuleCall_1_0() { return cConditionAssignmentStatementParserRuleCall_1_0; }
		
		//('THEN' thenClause=Statements)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'THEN'
		public Keyword getTHENKeyword_2_0() { return cTHENKeyword_2_0; }
		
		//thenClause=Statements
		public Assignment getThenClauseAssignment_2_1() { return cThenClauseAssignment_2_1; }
		
		//Statements
		public RuleCall getThenClauseStatementsParserRuleCall_2_1_0() { return cThenClauseStatementsParserRuleCall_2_1_0; }
		
		//('ELSE' elseClause=Statements)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'ELSE'
		public Keyword getELSEKeyword_3_0() { return cELSEKeyword_3_0; }
		
		//elseClause=Statements
		public Assignment getElseClauseAssignment_3_1() { return cElseClauseAssignment_3_1; }
		
		//Statements
		public RuleCall getElseClauseStatementsParserRuleCall_3_1_0() { return cElseClauseStatementsParserRuleCall_3_1_0; }
		
		//'END'
		public Keyword getENDKeyword_4() { return cENDKeyword_4; }
	}
	public class UntilStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.UntilStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUNTILKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionAssignmentStatementParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cDOKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyStatementsParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final Keyword cENDKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// loads condition in A and if false (<=0) executes loop
		//UntilStatement:
		//    'UNTIL' condition=AssignmentStatement 'DO' body=Statements 'END'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'UNTIL' condition=AssignmentStatement 'DO' body=Statements 'END'
		public Group getGroup() { return cGroup; }
		
		//'UNTIL'
		public Keyword getUNTILKeyword_0() { return cUNTILKeyword_0; }
		
		//condition=AssignmentStatement
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//AssignmentStatement
		public RuleCall getConditionAssignmentStatementParserRuleCall_1_0() { return cConditionAssignmentStatementParserRuleCall_1_0; }
		
		//'DO'
		public Keyword getDOKeyword_2() { return cDOKeyword_2; }
		
		//body=Statements
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Statements
		public RuleCall getBodyStatementsParserRuleCall_3_0() { return cBodyStatementsParserRuleCall_3_0; }
		
		//'END'
		public Keyword getENDKeyword_4() { return cENDKeyword_4; }
	}
	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFORKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInitAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cInitAlternatives_1_0 = (Alternatives)cInitAssignment_1.eContents().get(0);
		private final RuleCall cInitAssignmentStatementParserRuleCall_1_0_0 = (RuleCall)cInitAlternatives_1_0.eContents().get(0);
		private final RuleCall cInitSimpleStatementParserRuleCall_1_0_1 = (RuleCall)cInitAlternatives_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cConditionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConditionAssignmentStatementParserRuleCall_3_0 = (RuleCall)cConditionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Alternatives cEndAlternatives_5_0 = (Alternatives)cEndAssignment_5.eContents().get(0);
		private final RuleCall cEndAssignmentStatementParserRuleCall_5_0_0 = (RuleCall)cEndAlternatives_5_0.eContents().get(0);
		private final RuleCall cEndSimpleStatementParserRuleCall_5_0_1 = (RuleCall)cEndAlternatives_5_0.eContents().get(1);
		private final Keyword cDOKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBodyAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBodyStatementsParserRuleCall_7_0 = (RuleCall)cBodyAssignment_7.eContents().get(0);
		private final Keyword cENDKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		////
		//// Equivalent to
		////
		//// init
		//// UNTIL condition
		////   body
		////   end
		//// END
		//ForStatement:
		//    'FOR' init=(AssignmentStatement | SimpleStatement)? ';'
		//        condition=AssignmentStatement  ';'
		//        end=(AssignmentStatement | SimpleStatement)?
		//    'DO' body=Statements 'END'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'FOR' init=(AssignmentStatement | SimpleStatement)? ';'
		//    condition=AssignmentStatement  ';'
		//    end=(AssignmentStatement | SimpleStatement)?
		//'DO' body=Statements 'END'
		public Group getGroup() { return cGroup; }
		
		//'FOR'
		public Keyword getFORKeyword_0() { return cFORKeyword_0; }
		
		//init=(AssignmentStatement | SimpleStatement)?
		public Assignment getInitAssignment_1() { return cInitAssignment_1; }
		
		//(AssignmentStatement | SimpleStatement)
		public Alternatives getInitAlternatives_1_0() { return cInitAlternatives_1_0; }
		
		//AssignmentStatement
		public RuleCall getInitAssignmentStatementParserRuleCall_1_0_0() { return cInitAssignmentStatementParserRuleCall_1_0_0; }
		
		//SimpleStatement
		public RuleCall getInitSimpleStatementParserRuleCall_1_0_1() { return cInitSimpleStatementParserRuleCall_1_0_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//condition=AssignmentStatement
		public Assignment getConditionAssignment_3() { return cConditionAssignment_3; }
		
		//AssignmentStatement
		public RuleCall getConditionAssignmentStatementParserRuleCall_3_0() { return cConditionAssignmentStatementParserRuleCall_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
		
		//end=(AssignmentStatement | SimpleStatement)?
		public Assignment getEndAssignment_5() { return cEndAssignment_5; }
		
		//(AssignmentStatement | SimpleStatement)
		public Alternatives getEndAlternatives_5_0() { return cEndAlternatives_5_0; }
		
		//AssignmentStatement
		public RuleCall getEndAssignmentStatementParserRuleCall_5_0_0() { return cEndAssignmentStatementParserRuleCall_5_0_0; }
		
		//SimpleStatement
		public RuleCall getEndSimpleStatementParserRuleCall_5_0_1() { return cEndSimpleStatementParserRuleCall_5_0_1; }
		
		//'DO'
		public Keyword getDOKeyword_6() { return cDOKeyword_6; }
		
		//body=Statements
		public Assignment getBodyAssignment_7() { return cBodyAssignment_7; }
		
		//Statements
		public RuleCall getBodyStatementsParserRuleCall_7_0() { return cBodyStatementsParserRuleCall_7_0; }
		
		//'END'
		public Keyword getENDKeyword_8() { return cENDKeyword_8; }
	}
	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDOKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyStatementsParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		private final Keyword cWHILEKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cConditionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConditionAssignmentStatementParserRuleCall_3_0 = (RuleCall)cConditionAssignment_3.eContents().get(0);
		private final Keyword cENDKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// executes body, then loads condition in A and if true(>0) loops
		//WhileStatement:
		//    'DO' body=Statements 'WHILE' condition=AssignmentStatement 'END'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'DO' body=Statements 'WHILE' condition=AssignmentStatement 'END'
		public Group getGroup() { return cGroup; }
		
		//'DO'
		public Keyword getDOKeyword_0() { return cDOKeyword_0; }
		
		//body=Statements
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }
		
		//Statements
		public RuleCall getBodyStatementsParserRuleCall_1_0() { return cBodyStatementsParserRuleCall_1_0; }
		
		//'WHILE'
		public Keyword getWHILEKeyword_2() { return cWHILEKeyword_2; }
		
		//condition=AssignmentStatement
		public Assignment getConditionAssignment_3() { return cConditionAssignment_3; }
		
		//AssignmentStatement
		public RuleCall getConditionAssignmentStatementParserRuleCall_3_0() { return cConditionAssignmentStatementParserRuleCall_3_0; }
		
		//'END'
		public Keyword getENDKeyword_4() { return cENDKeyword_4; }
	}
	
	
	private final ProgramElements pProgram;
	private final VariableDeclarationElements pVariableDeclaration;
	private final VariableElements pVariable;
	private final VariableAccessElements pVariableAccess;
	private final VariableOrUserInputElements pVariableOrUserInput;
	private final AssignmentStatementElements pAssignmentStatement;
	private final ExpressionElements pExpression;
	private final AdditiveOperatorElements pAdditiveOperator;
	private final MultiplicativeOperatorElements pMultiplicativeOperator;
	private final UnaryOperatorElements pUnaryOperator;
	private final AtomicElements pAtomic;
	private final CurrentElements pCurrent;
	private final UserInputElements pUserInput;
	private final ConstantElements pConstant;
	private final StatementsElements pStatements;
	private final StatementElements pStatement;
	private final LabelElements pLabel;
	private final SimpleStatementElements pSimpleStatement;
	private final SimpleControlStatementElements pSimpleControlStatement;
	private final StructuredControlStatementElements pStructuredControlStatement;
	private final LoopStatementElements pLoopStatement;
	private final StoreStatementElements pStoreStatement;
	private final PrintStatementElements pPrintStatement;
	private final PrintParameterElements pPrintParameter;
	private final NewLineElements pNewLine;
	private final GotoStatementElements pGotoStatement;
	private final ContinueStatementElements pContinueStatement;
	private final BreakStatementElements pBreakStatement;
	private final IfStatementElements pIfStatement;
	private final UntilStatementElements pUntilStatement;
	private final ForStatementElements pForStatement;
	private final WhileStatementElements pWhileStatement;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tID;
	private final TerminalRule tNUMBER;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public L101GrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pProgram = new ProgramElements();
		this.pVariableDeclaration = new VariableDeclarationElements();
		this.pVariable = new VariableElements();
		this.pVariableAccess = new VariableAccessElements();
		this.pVariableOrUserInput = new VariableOrUserInputElements();
		this.pAssignmentStatement = new AssignmentStatementElements();
		this.pExpression = new ExpressionElements();
		this.pAdditiveOperator = new AdditiveOperatorElements();
		this.pMultiplicativeOperator = new MultiplicativeOperatorElements();
		this.pUnaryOperator = new UnaryOperatorElements();
		this.pAtomic = new AtomicElements();
		this.pCurrent = new CurrentElements();
		this.pUserInput = new UserInputElements();
		this.pConstant = new ConstantElements();
		this.pStatements = new StatementsElements();
		this.pStatement = new StatementElements();
		this.pLabel = new LabelElements();
		this.pSimpleStatement = new SimpleStatementElements();
		this.pSimpleControlStatement = new SimpleControlStatementElements();
		this.pStructuredControlStatement = new StructuredControlStatementElements();
		this.pLoopStatement = new LoopStatementElements();
		this.pStoreStatement = new StoreStatementElements();
		this.pPrintStatement = new PrintStatementElements();
		this.pPrintParameter = new PrintParameterElements();
		this.pNewLine = new NewLineElements();
		this.pGotoStatement = new GotoStatementElements();
		this.pContinueStatement = new ContinueStatementElements();
		this.pBreakStatement = new BreakStatementElements();
		this.pIfStatement = new IfStatementElements();
		this.pUntilStatement = new UntilStatementElements();
		this.pForStatement = new ForStatementElements();
		this.pWhileStatement = new WhileStatementElements();
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.SL_COMMENT");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.ID");
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.NUMBER");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mzattera.dsl.L101.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.mzattera.dsl.L101".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Program:
	//    (varDeclarations+=VariableDeclaration)*
	//    body=Statements
	//;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//VariableDeclaration:
	//    (short?='SHORT' | 'LONG') vars+=Variable (',' vars+=Variable)* ';'
	//;
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return pVariableDeclaration;
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}
	
	//// Even though it would be possible to automatically allocate variables, we don't because then variables
	//// can be recognized when a register is printed.
	//// Constant assignment cannot be done because the program entry point is unknown.
	//Variable:
	//    name=ID 'IN' reg=('B' | 'B/' | 'C' | 'C/' | 'D' | 'D/' | 'E' | 'E/' | 'F' | 'F/')
	//;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//// Pay attention this is scoped, therefore if you change feature names you need to change the scope provider.
	//VariableAccess returns Expression:
	//    {VariableAccess} store=[Variable]
	//;
	public VariableAccessElements getVariableAccessAccess() {
		return pVariableAccess;
	}
	
	public ParserRule getVariableAccessRule() {
		return getVariableAccessAccess().getRule();
	}
	
	//VariableOrUserInput returns Expression:
	//    VariableAccess
	//    | UserInput
	//;
	public VariableOrUserInputElements getVariableOrUserInputAccess() {
		return pVariableOrUserInput;
	}
	
	public ParserRule getVariableOrUserInputRule() {
		return getVariableOrUserInputAccess().getRule();
	}
	
	//    /// Expressions ////////////////////////////////////////////////////////////////////
	//    /*
	//     * We have 2 options here I think.
	//     *
	//     * 1) Allow 'A' to appear both as left and right operand with the meaning of "current value in A" and remove the "auto-assignment" operators.
	//     * This will allow more compact syntax but could be error prone because it has side effects:
	//     * A=1   A+A+A =4 (and not 3: (A+A) puts a two in A then +A sums 2+2)
	//     *
	//     * 2) Current situation: allow A to appear only a) as left operand and b) on the right of "auto-assignment" operators.
	//     * a) removes side effects because, given current syntax, A will appear only once in expressions as the first term to be evaluated
	//     * b) clearly shows when A is changed and again A value is read only once.
	//     * Syntax is less error prone but more complex and less concise though.
	//     */
	//AssignmentStatement:
	//    // x % y performs x/y then the "exact reminder" (content of R) is moved to A
	//    // Compute expression and stores it in A
	//    op='=' operand=Expression
	//    // Computes A = A <op> A/INPUT/Variable/Constant
	//    // this allows you to calculate A=A+A as +=A; which is not allowed with "=" statement alone for the above reasons.
	//    | op=('+=' | '-=' | '/=' | '*=' | '%=') operand=(VariableOrUserInput | Current | Constant)
	//    // Computes expression in A then swaps A with given variable
	//    | store=VariableAccess op='<->' operand=Expression
	//;
	public AssignmentStatementElements getAssignmentStatementAccess() {
		return pAssignmentStatement;
	}
	
	public ParserRule getAssignmentStatementRule() {
		return getAssignmentStatementAccess().getRule();
	}
	
	//// TODO 3 - write test code to check expressions (precedence, associativity)
	//Expression:
	//    AdditiveOperator
	//;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//AdditiveOperator returns Expression: // left associative
	//    MultiplicativeOperator ({AdditiveOperator.left=current} op=('+' | '-') right=(VariableOrUserInput | Constant))*
	//;
	public AdditiveOperatorElements getAdditiveOperatorAccess() {
		return pAdditiveOperator;
	}
	
	public ParserRule getAdditiveOperatorRule() {
		return getAdditiveOperatorAccess().getRule();
	}
	
	//MultiplicativeOperator returns Expression: // left associative
	//    // x % y performs x/y then the "exact reminder" (content of R) is moved to A
	//    UnaryOperator ({MultiplicativeOperator.left=current} op=('*' | '/' | '%') right=(VariableOrUserInput | Constant))*
	//;
	public MultiplicativeOperatorElements getMultiplicativeOperatorAccess() {
		return pMultiplicativeOperator;
	}
	
	public ParserRule getMultiplicativeOperatorRule() {
		return getMultiplicativeOperatorAccess().getRule();
	}
	
	//UnaryOperator returns Expression: // right associative
	//    {UnaryOperator} op=('SQ' | 'SQRT' | 'INT' | 'DEC' | 'INV' | 'NEG' | 'ABS') operand=(UnaryOperator)
	//    | Atomic
	//;
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return pUnaryOperator;
	}
	
	public ParserRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}
	
	//Atomic returns Expression:
	//    VariableAccess
	//    | Current
	//    | UserInput
	//    | Constant
	//    | '(' Expression ')'
	//;
	public AtomicElements getAtomicAccess() {
		return pAtomic;
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}
	
	//Current returns Expression:
	//    {Current} 'A'
	//;
	public CurrentElements getCurrentAccess() {
		return pCurrent;
	}
	
	public ParserRule getCurrentRule() {
		return getCurrentAccess().getRule();
	}
	
	//UserInput returns Expression:
	//    {Input} 'INPUT'
	//;
	public UserInputElements getUserInputAccess() {
		return pUserInput;
	}
	
	public ParserRule getUserInputRule() {
		return getUserInputAccess().getRule();
	}
	
	//Constant returns Expression:
	//// Not ideal, as can be space between - and the number,but necessary otherwise i-10 won't be parsed (-10 will be a single indivisible token)
	//// Notice it is the same in Java.
	//// Notice maximum number of digit in a constant is 11.
	//    {Constant} negative?='-'? value=NUMBER
	//;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	///// Statements ///////////////////////////////////////////////////
	//Statements:
	//        {Statements} (statements+=Statement)*
	//;
	public StatementsElements getStatementsAccess() {
		return pStatements;
	}
	
	public ParserRule getStatementsRule() {
		return getStatementsAccess().getRule();
	}
	
	//Statement:
	//    Label
	//    | AssignmentStatement ';'
	//    | SimpleStatement ';'
	//    | SimpleControlStatement ';'
	//    | StructuredControlStatement
	//;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//Label:
	//    name=ID ('ON' target=('V' | 'W' | 'Y' | 'Z'))? ':'
	//;
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}
	
	//SimpleStatement:
	//    StoreStatement
	//    | PrintStatement
	//    | GotoStatement
	//;
	public SimpleStatementElements getSimpleStatementAccess() {
		return pSimpleStatement;
	}
	
	public ParserRule getSimpleStatementRule() {
		return getSimpleStatementAccess().getRule();
	}
	
	//// Keep these separate from SimpleStatemetns since they have different usage in FOR for example
	//SimpleControlStatement:
	//    ContinueStatement
	//    | BreakStatement
	//;
	public SimpleControlStatementElements getSimpleControlStatementAccess() {
		return pSimpleControlStatement;
	}
	
	public ParserRule getSimpleControlStatementRule() {
		return getSimpleControlStatementAccess().getRule();
	}
	
	//StructuredControlStatement:
	//    IfStatement
	//    | LoopStatement
	//;
	public StructuredControlStatementElements getStructuredControlStatementAccess() {
		return pStructuredControlStatement;
	}
	
	public ParserRule getStructuredControlStatementRule() {
		return getStructuredControlStatementAccess().getRule();
	}
	
	//LoopStatement:
	//    UntilStatement
	//    | ForStatement
	//    | WhileStatement
	//;
	public LoopStatementElements getLoopStatementAccess() {
		return pLoopStatement;
	}
	
	public ParserRule getLoopStatementRule() {
		return getLoopStatementAccess().getRule();
	}
	
	//StoreStatement:
	//    param=(Constant | UserInput) '->' store=VariableAccess
	//;
	public StoreStatementElements getStoreStatementAccess() {
		return pStoreStatement;
	}
	
	public ParserRule getStoreStatementRule() {
		return getStoreStatementAccess().getRule();
	}
	
	//// Prints given parameters.
	//// Parameters can be a variable: prints its value, "Current": prints content of A,
	//// "NL" to print an empty line, "Constant" prints a number.
	//// If no parameters are provided, prints a new line.
	//PrintStatement:
	//    {PrintStatement} 'PRINT' (params+=PrintParameter (',' params+=PrintParameter)*)?
	//;
	public PrintStatementElements getPrintStatementAccess() {
		return pPrintStatement;
	}
	
	public ParserRule getPrintStatementRule() {
		return getPrintStatementAccess().getRule();
	}
	
	//PrintParameter:
	//    VariableAccess
	//    | Current
	//    | Constant
	//    | NewLine
	//;
	public PrintParameterElements getPrintParameterAccess() {
		return pPrintParameter;
	}
	
	public ParserRule getPrintParameterRule() {
		return getPrintParameterAccess().getRule();
	}
	
	//NewLine:
	//    {NewLine} 'NL'
	//;
	public NewLineElements getNewLineAccess() {
		return pNewLine;
	}
	
	public ParserRule getNewLineRule() {
		return getNewLineAccess().getRule();
	}
	
	//GotoStatement:
	//    'GOTO' label=[Label]
	//;
	public GotoStatementElements getGotoStatementAccess() {
		return pGotoStatement;
	}
	
	public ParserRule getGotoStatementRule() {
		return getGotoStatementAccess().getRule();
	}
	
	//// Code is not really used, it used to point to a feature during validation
	//ContinueStatement:
	//    {ContinueStatement} code='CONTINUE'
	//;
	public ContinueStatementElements getContinueStatementAccess() {
		return pContinueStatement;
	}
	
	public ParserRule getContinueStatementRule() {
		return getContinueStatementAccess().getRule();
	}
	
	//// Code is not really used, it used to point to a feature during validation
	//BreakStatement:
	//    {BreakStatement} code='BREAK'
	//;
	public BreakStatementElements getBreakStatementAccess() {
		return pBreakStatement;
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}
	
	//// Code is not really used, it used to point to a feature during validation
	//IfStatement:
	//    code='IF' condition=AssignmentStatement ('THEN' thenClause=Statements)? ('ELSE' elseClause=Statements)? 'END'
	//;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	//// loads condition in A and if false (<=0) executes loop
	//UntilStatement:
	//    'UNTIL' condition=AssignmentStatement 'DO' body=Statements 'END'
	//;
	public UntilStatementElements getUntilStatementAccess() {
		return pUntilStatement;
	}
	
	public ParserRule getUntilStatementRule() {
		return getUntilStatementAccess().getRule();
	}
	
	////
	//// Equivalent to
	////
	//// init
	//// UNTIL condition
	////   body
	////   end
	//// END
	//ForStatement:
	//    'FOR' init=(AssignmentStatement | SimpleStatement)? ';'
	//        condition=AssignmentStatement  ';'
	//        end=(AssignmentStatement | SimpleStatement)?
	//    'DO' body=Statements 'END'
	//;
	public ForStatementElements getForStatementAccess() {
		return pForStatement;
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}
	
	//// executes body, then loads condition in A and if true(>0) loops
	//WhileStatement:
	//    'DO' body=Statements 'WHILE' condition=AssignmentStatement 'END'
	//;
	public WhileStatementElements getWhileStatementAccess() {
		return pWhileStatement;
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}
	
	//terminal ML_COMMENT:
	//    '/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//    '//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal ID:
	//    ('a'..'z') ('A'..'Z' | 'a'..'z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//// TODO 3 - allow leading and trailing 0s; remove them after compilation. IF you do so, add code to validate the number length.
	//// TODO 3 - use some thousand separator
	//terminal NUMBER:
	//    (('1'..'9'('0'..'9')*) |'0') ('.'('0'..'9')*('1'..'9'))?
	//;
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	}
	
	//terminal WS:
	//    (' ' | '\t' | '\r' | '\n')+;
	public TerminalRule getWSRule() {
		return tWS;
	}
}
