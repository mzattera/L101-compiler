/**
 * generated by Xtext 2.18.0
 */
package org.mzattera.dsl.validation;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.mzattera.dsl.l101.BreakStatement;
import org.mzattera.dsl.l101.Constant;
import org.mzattera.dsl.l101.ContinueStatement;
import org.mzattera.dsl.l101.GotoStatement;
import org.mzattera.dsl.l101.IfStatement;
import org.mzattera.dsl.l101.L101Package;
import org.mzattera.dsl.l101.Label;
import org.mzattera.dsl.l101.LoopStatement;
import org.mzattera.dsl.l101.Program;
import org.mzattera.dsl.l101.Statement;
import org.mzattera.dsl.l101.Variable;
import org.mzattera.dsl.l101.VariableDeclaration;
import org.mzattera.dsl.util.Extensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class L101Validator extends AbstractL101Validator {
  private static final String ISSUE_CODE_PREFIX = "org.mzattera.dsl.validation";

  public static final String DUPLICATED_KEY = (L101Validator.ISSUE_CODE_PREFIX + "DuplicatedKey");

  public static final String DUPLICATED_REGISTER = (L101Validator.ISSUE_CODE_PREFIX + "DuplicatedRegister");

  public static final String INCONSISTENT_REGISTER = (L101Validator.ISSUE_CODE_PREFIX + "InconsistentRegister");

  public static final String CONTINUE_CONTAINER = (L101Validator.ISSUE_CODE_PREFIX + "ContinueContainer");

  public static final String BREAK_CONTAINER = (L101Validator.ISSUE_CODE_PREFIX + "BreakContainer");

  public static final String EMPTY_IF = (L101Validator.ISSUE_CODE_PREFIX + "EmptyIf");

  public static final String LONG_CONSTANT = (L101Validator.ISSUE_CODE_PREFIX + "LongConstants");

  public static final String UNREACHABLE_CODE = (L101Validator.ISSUE_CODE_PREFIX + "UnreachableCode");

  public static final String UNUSED_LABEL = (L101Validator.ISSUE_CODE_PREFIX + "UnusedLabel");

  /**
   * In a program registers must be used consistently
   */
  @Check
  public void checkRegisters(final Program prg) {
    Set<String> used = new HashSet<String>();
    Set<String> lng = new HashSet<String>();
    Set<String> shr = new HashSet<String>();
    EList<VariableDeclaration> _varDeclarations = prg.getVarDeclarations();
    for (final VariableDeclaration dec : _varDeclarations) {
      EList<Variable> _vars = dec.getVars();
      for (final Variable v : _vars) {
        {
          boolean _contains = used.contains(v.getReg());
          if (_contains) {
            this.error("Duplicated register.", v, L101Package.eINSTANCE.getVariable_Reg(), L101Validator.DUPLICATED_REGISTER);
          } else {
            boolean _isShort = dec.isShort();
            if (_isShort) {
              String fr = Character.toString(v.getReg().charAt(0));
              boolean _contains_1 = lng.contains(fr);
              if (_contains_1) {
                this.error("Register used inconsistently (both for LONG and SHORT).", v, 
                  L101Package.eINSTANCE.getVariable_Reg(), L101Validator.INCONSISTENT_REGISTER);
              }
              shr.add(v.getReg());
            } else {
              int _length = v.getReg().length();
              boolean _greaterThan = (_length > 1);
              if (_greaterThan) {
                this.error("Short register cannot be used for LONG variable.", v, 
                  L101Package.eINSTANCE.getVariable_Reg(), L101Validator.INCONSISTENT_REGISTER);
              }
              if ((shr.contains(v.getReg()) || shr.contains((v.getReg() + "/")))) {
                this.error("Register used inconsistently (both for LONG and SHORT).", v, 
                  L101Package.eINSTANCE.getVariable_Reg(), L101Validator.INCONSISTENT_REGISTER);
              }
              lng.add(v.getReg());
            }
          }
          used.add(v.getReg());
        }
      }
    }
  }

  /**
   * Constants at maximum have 11 digits. WHY? P101Emul breaks if longer.
   */
  @Check
  public void checkConstLength(final Constant c) {
    int _length = c.getValue().replaceAll("\\.", "").length();
    boolean _greaterThan = (_length > 11);
    if (_greaterThan) {
      this.error("Numeric constant too long.", c, L101Package.eINSTANCE.getConstant_Value(), L101Validator.LONG_CONSTANT);
    }
  }

  /**
   * In a program only 4 distinct labels can be assigned to VWYZ keys
   */
  @Check
  public void checkLabelAssignments(final Program prg) {
    Set<String> used = new HashSet<String>();
    final Function1<EObject, Boolean> _function = (EObject it) -> {
      return Boolean.valueOf((it instanceof Label));
    };
    final Iterator<EObject> labels = IteratorExtensions.<EObject>filter(prg.eAllContents(), _function);
    while (labels.hasNext()) {
      {
        EObject _next = labels.next();
        final Label lbl = ((Label) _next);
        String _target = lbl.getTarget();
        boolean _tripleNotEquals = (_target != null);
        if (_tripleNotEquals) {
          boolean _contains = used.contains(lbl.getTarget());
          if (_contains) {
            this.error("Duplicated key assignment for label.", lbl, L101Package.eINSTANCE.getLabel_Target(), 
              L101Validator.DUPLICATED_KEY);
          } else {
            used.add(lbl.getTarget());
          }
        }
      }
    }
  }

  /**
   * Check wheter all declared labels are used.
   */
  @Check
  public void checkUnusedLabels(final Program prg) {
    Set<Label> used = new HashSet<Label>();
    final Function1<EObject, Boolean> _function = (EObject it) -> {
      return Boolean.valueOf((it instanceof GotoStatement));
    };
    final Iterator<EObject> gotos = IteratorExtensions.<EObject>filter(prg.eAllContents(), _function);
    while (gotos.hasNext()) {
      EObject _next = gotos.next();
      used.add(((GotoStatement) _next).getLabel());
    }
    final Function1<EObject, Boolean> _function_1 = (EObject it) -> {
      return Boolean.valueOf((it instanceof Label));
    };
    final Iterator<EObject> labels = IteratorExtensions.<EObject>filter(prg.eAllContents(), _function_1);
    while (labels.hasNext()) {
      {
        EObject _next = labels.next();
        final Label lbl = ((Label) _next);
        if (((lbl.getTarget() == null) && (!used.contains(lbl)))) {
          String _name = lbl.getName();
          String _plus = ("Unused label: " + _name);
          this.warning(_plus, lbl, L101Package.eINSTANCE.getLabel_Name(), L101Validator.UNUSED_LABEL);
        }
      }
    }
  }

  /**
   * Unreachable code check.
   * If a statement is in Statements and the preceding statement is GOTO BREAK CONTINUE, code is unreachable.
   * Issue an error (or warning?). It will work also for an optimized GOTO.
   */
  @Check
  public void checkUnreachableCode(final Statement stmt) {
    if ((stmt instanceof Label)) {
      return;
    }
    final EObject container = stmt.eContainer();
    int index = container.eContents().indexOf(stmt);
    if ((index > 0)) {
      final EObject prec = container.eContents().get((index - 1));
      if ((((prec instanceof GotoStatement) || (prec instanceof BreakStatement)) || (prec instanceof ContinueStatement))) {
        this.warning("Unreachable code.", container, stmt.eContainingFeature(), index, 
          L101Validator.UNREACHABLE_CODE);
      }
    }
  }

  /**
   * Continue statements must be contained in a loop.
   */
  @Check
  public void checkContinueContainer(final ContinueStatement stmt) {
    LoopStatement _containingLoop = Extensions.getContainingLoop(stmt);
    boolean _tripleEquals = (_containingLoop == null);
    if (_tripleEquals) {
      this.error("CONTINUE statement must be contained within a loop.", stmt, 
        L101Package.eINSTANCE.getSimpleControlStatement_Code(), L101Validator.CONTINUE_CONTAINER);
    }
  }

  /**
   * Break statements must be contained in a loop.
   */
  @Check
  public void checkBreakContainer(final BreakStatement stmt) {
    LoopStatement _containingLoop = Extensions.getContainingLoop(stmt);
    boolean _tripleEquals = (_containingLoop == null);
    if (_tripleEquals) {
      this.error("BREAK statement must be contained within a loop.", stmt, 
        L101Package.eINSTANCE.getSimpleControlStatement_Code(), L101Validator.BREAK_CONTAINER);
    }
  }

  /**
   * IF statements must either have a non-empty THEN or an ELSE clause.
   */
  @Check
  public void checkIf(final IfStatement stmt) {
    if ((Extensions.isThenEmpty(stmt) && Extensions.isElseEmpty(stmt))) {
      this.error("IF statement must either have a non-empty THEN or ELSE clause.", stmt, 
        L101Package.eINSTANCE.getIfStatement_Code(), L101Validator.EMPTY_IF);
    }
  }
}
